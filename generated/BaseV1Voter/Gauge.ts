// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class ClaimFees extends ethereum.Event {
  get params(): ClaimFees__Params {
    return new ClaimFees__Params(this);
  }
}

export class ClaimFees__Params {
  _event: ClaimFees;

  constructor(event: ClaimFees) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get claimed0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get claimed1(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ClaimRewards extends ethereum.Event {
  get params(): ClaimRewards__Params {
    return new ClaimRewards__Params(this);
  }
}

export class ClaimRewards__Params {
  _event: ClaimRewards;

  constructor(event: ClaimRewards) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reward(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Deposit extends ethereum.Event {
  get params(): Deposit__Params {
    return new Deposit__Params(this);
  }
}

export class Deposit__Params {
  _event: Deposit;

  constructor(event: Deposit) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NotifyReward extends ethereum.Event {
  get params(): NotifyReward__Params {
    return new NotifyReward__Params(this);
  }
}

export class NotifyReward__Params {
  _event: NotifyReward;

  constructor(event: NotifyReward) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reward(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Gauge__checkpointsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Gauge__claimFeesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Gauge__getPriorRewardPerTokenResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Gauge__rewardPerTokenCheckpointsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Gauge__supplyCheckpointsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Gauge extends ethereum.SmartContract {
  static bind(address: Address): Gauge {
    return new Gauge("Gauge", address);
  }

  _ve(): Address {
    let result = super.call("_ve", "_ve():(address)", []);

    return result[0].toAddress();
  }

  try__ve(): ethereum.CallResult<Address> {
    let result = super.tryCall("_ve", "_ve():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf(param0: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  bribe(): Address {
    let result = super.call("bribe", "bribe():(address)", []);

    return result[0].toAddress();
  }

  try_bribe(): ethereum.CallResult<Address> {
    let result = super.tryCall("bribe", "bribe():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  checkpoints(param0: Address, param1: BigInt): Gauge__checkpointsResult {
    let result = super.call(
      "checkpoints",
      "checkpoints(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new Gauge__checkpointsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_checkpoints(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<Gauge__checkpointsResult> {
    let result = super.tryCall(
      "checkpoints",
      "checkpoints(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Gauge__checkpointsResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  claimFees(): Gauge__claimFeesResult {
    let result = super.call("claimFees", "claimFees():(uint256,uint256)", []);

    return new Gauge__claimFeesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_claimFees(): ethereum.CallResult<Gauge__claimFeesResult> {
    let result = super.tryCall(
      "claimFees",
      "claimFees():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Gauge__claimFeesResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  derivedBalance(account: Address): BigInt {
    let result = super.call(
      "derivedBalance",
      "derivedBalance(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_derivedBalance(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "derivedBalance",
      "derivedBalance(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  derivedBalances(param0: Address): BigInt {
    let result = super.call(
      "derivedBalances",
      "derivedBalances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_derivedBalances(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "derivedBalances",
      "derivedBalances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  derivedSupply(): BigInt {
    let result = super.call("derivedSupply", "derivedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_derivedSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "derivedSupply",
      "derivedSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  earned(token: Address, account: Address): BigInt {
    let result = super.call("earned", "earned(address,address):(uint256)", [
      ethereum.Value.fromAddress(token),
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_earned(token: Address, account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("earned", "earned(address,address):(uint256)", [
      ethereum.Value.fromAddress(token),
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fees0(): BigInt {
    let result = super.call("fees0", "fees0():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fees0(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("fees0", "fees0():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fees1(): BigInt {
    let result = super.call("fees1", "fees1():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fees1(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("fees1", "fees1():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriorBalanceIndex(account: Address, timestamp: BigInt): BigInt {
    let result = super.call(
      "getPriorBalanceIndex",
      "getPriorBalanceIndex(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPriorBalanceIndex(
    account: Address,
    timestamp: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriorBalanceIndex",
      "getPriorBalanceIndex(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriorRewardPerToken(
    token: Address,
    timestamp: BigInt
  ): Gauge__getPriorRewardPerTokenResult {
    let result = super.call(
      "getPriorRewardPerToken",
      "getPriorRewardPerToken(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );

    return new Gauge__getPriorRewardPerTokenResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getPriorRewardPerToken(
    token: Address,
    timestamp: BigInt
  ): ethereum.CallResult<Gauge__getPriorRewardPerTokenResult> {
    let result = super.tryCall(
      "getPriorRewardPerToken",
      "getPriorRewardPerToken(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Gauge__getPriorRewardPerTokenResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getPriorSupplyIndex(timestamp: BigInt): BigInt {
    let result = super.call(
      "getPriorSupplyIndex",
      "getPriorSupplyIndex(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );

    return result[0].toBigInt();
  }

  try_getPriorSupplyIndex(timestamp: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriorSupplyIndex",
      "getPriorSupplyIndex(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isReward(param0: Address): boolean {
    let result = super.call("isReward", "isReward(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_isReward(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isReward", "isReward(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastEarn(param0: Address, param1: Address): BigInt {
    let result = super.call("lastEarn", "lastEarn(address,address):(uint256)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1)
    ]);

    return result[0].toBigInt();
  }

  try_lastEarn(param0: Address, param1: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastEarn",
      "lastEarn(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastTimeRewardApplicable(token: Address): BigInt {
    let result = super.call(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_lastTimeRewardApplicable(token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastUpdateTime(param0: Address): BigInt {
    let result = super.call(
      "lastUpdateTime",
      "lastUpdateTime(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_lastUpdateTime(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastUpdateTime",
      "lastUpdateTime(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  left(token: Address): BigInt {
    let result = super.call("left", "left(address):(uint256)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBigInt();
  }

  try_left(token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("left", "left(address):(uint256)", [
      ethereum.Value.fromAddress(token)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  numCheckpoints(param0: Address): BigInt {
    let result = super.call(
      "numCheckpoints",
      "numCheckpoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_numCheckpoints(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "numCheckpoints",
      "numCheckpoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  periodFinish(param0: Address): BigInt {
    let result = super.call("periodFinish", "periodFinish(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_periodFinish(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "periodFinish",
      "periodFinish(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardPerToken(token: Address): BigInt {
    let result = super.call(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerToken(token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardPerTokenCheckpoints(
    param0: Address,
    param1: BigInt
  ): Gauge__rewardPerTokenCheckpointsResult {
    let result = super.call(
      "rewardPerTokenCheckpoints",
      "rewardPerTokenCheckpoints(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new Gauge__rewardPerTokenCheckpointsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_rewardPerTokenCheckpoints(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<Gauge__rewardPerTokenCheckpointsResult> {
    let result = super.tryCall(
      "rewardPerTokenCheckpoints",
      "rewardPerTokenCheckpoints(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Gauge__rewardPerTokenCheckpointsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  rewardPerTokenNumCheckpoints(param0: Address): BigInt {
    let result = super.call(
      "rewardPerTokenNumCheckpoints",
      "rewardPerTokenNumCheckpoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerTokenNumCheckpoints(
    param0: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardPerTokenNumCheckpoints",
      "rewardPerTokenNumCheckpoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardPerTokenStored(param0: Address): BigInt {
    let result = super.call(
      "rewardPerTokenStored",
      "rewardPerTokenStored(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerTokenStored(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardPerTokenStored",
      "rewardPerTokenStored(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardRate(param0: Address): BigInt {
    let result = super.call("rewardRate", "rewardRate(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_rewardRate(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rewardRate", "rewardRate(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewards(param0: BigInt): Address {
    let result = super.call("rewards", "rewards(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_rewards(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("rewards", "rewards(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardsListLength(): BigInt {
    let result = super.call(
      "rewardsListLength",
      "rewardsListLength():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsListLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardsListLength",
      "rewardsListLength():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stake(): Address {
    let result = super.call("stake", "stake():(address)", []);

    return result[0].toAddress();
  }

  try_stake(): ethereum.CallResult<Address> {
    let result = super.tryCall("stake", "stake():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  supplyCheckpoints(param0: BigInt): Gauge__supplyCheckpointsResult {
    let result = super.call(
      "supplyCheckpoints",
      "supplyCheckpoints(uint256):(uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new Gauge__supplyCheckpointsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_supplyCheckpoints(
    param0: BigInt
  ): ethereum.CallResult<Gauge__supplyCheckpointsResult> {
    let result = super.tryCall(
      "supplyCheckpoints",
      "supplyCheckpoints(uint256):(uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Gauge__supplyCheckpointsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  supplyNumCheckpoints(): BigInt {
    let result = super.call(
      "supplyNumCheckpoints",
      "supplyNumCheckpoints():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_supplyNumCheckpoints(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "supplyNumCheckpoints",
      "supplyNumCheckpoints():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenIds(param0: Address): BigInt {
    let result = super.call("tokenIds", "tokenIds(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_tokenIds(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("tokenIds", "tokenIds(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userRewardPerTokenStored(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "userRewardPerTokenStored",
      "userRewardPerTokenStored(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_userRewardPerTokenStored(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userRewardPerTokenStored",
      "userRewardPerTokenStored(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  voter(): Address {
    let result = super.call("voter", "voter():(address)", []);

    return result[0].toAddress();
  }

  try_voter(): ethereum.CallResult<Address> {
    let result = super.tryCall("voter", "voter():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _stake(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _bribe(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get __ve(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _voter(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class BatchRewardPerTokenCall extends ethereum.Call {
  get inputs(): BatchRewardPerTokenCall__Inputs {
    return new BatchRewardPerTokenCall__Inputs(this);
  }

  get outputs(): BatchRewardPerTokenCall__Outputs {
    return new BatchRewardPerTokenCall__Outputs(this);
  }
}

export class BatchRewardPerTokenCall__Inputs {
  _call: BatchRewardPerTokenCall;

  constructor(call: BatchRewardPerTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get maxRuns(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BatchRewardPerTokenCall__Outputs {
  _call: BatchRewardPerTokenCall;

  constructor(call: BatchRewardPerTokenCall) {
    this._call = call;
  }
}

export class ClaimFeesCall extends ethereum.Call {
  get inputs(): ClaimFeesCall__Inputs {
    return new ClaimFeesCall__Inputs(this);
  }

  get outputs(): ClaimFeesCall__Outputs {
    return new ClaimFeesCall__Outputs(this);
  }
}

export class ClaimFeesCall__Inputs {
  _call: ClaimFeesCall;

  constructor(call: ClaimFeesCall) {
    this._call = call;
  }
}

export class ClaimFeesCall__Outputs {
  _call: ClaimFeesCall;

  constructor(call: ClaimFeesCall) {
    this._call = call;
  }

  get claimed0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get claimed1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }
}

export class DepositAllCall extends ethereum.Call {
  get inputs(): DepositAllCall__Inputs {
    return new DepositAllCall__Inputs(this);
  }

  get outputs(): DepositAllCall__Outputs {
    return new DepositAllCall__Outputs(this);
  }
}

export class DepositAllCall__Inputs {
  _call: DepositAllCall;

  constructor(call: DepositAllCall) {
    this._call = call;
  }

  get tokenId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class DepositAllCall__Outputs {
  _call: DepositAllCall;

  constructor(call: DepositAllCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }
}

export class NotifyRewardAmountCall extends ethereum.Call {
  get inputs(): NotifyRewardAmountCall__Inputs {
    return new NotifyRewardAmountCall__Inputs(this);
  }

  get outputs(): NotifyRewardAmountCall__Outputs {
    return new NotifyRewardAmountCall__Outputs(this);
  }
}

export class NotifyRewardAmountCall__Inputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class NotifyRewardAmountCall__Outputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawAllCall extends ethereum.Call {
  get inputs(): WithdrawAllCall__Inputs {
    return new WithdrawAllCall__Inputs(this);
  }

  get outputs(): WithdrawAllCall__Outputs {
    return new WithdrawAllCall__Outputs(this);
  }
}

export class WithdrawAllCall__Inputs {
  _call: WithdrawAllCall;

  constructor(call: WithdrawAllCall) {
    this._call = call;
  }
}

export class WithdrawAllCall__Outputs {
  _call: WithdrawAllCall;

  constructor(call: WithdrawAllCall) {
    this._call = call;
  }
}

export class WithdrawTokenCall extends ethereum.Call {
  get inputs(): WithdrawTokenCall__Inputs {
    return new WithdrawTokenCall__Inputs(this);
  }

  get outputs(): WithdrawTokenCall__Outputs {
    return new WithdrawTokenCall__Outputs(this);
  }
}

export class WithdrawTokenCall__Inputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WithdrawTokenCall__Outputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }
}
